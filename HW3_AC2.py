# -*- coding: utf-8 -*-
"""tugas3andro.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1iCuWcq8fF6vGNkILJrXs3dd56GTB42bJ
"""

pip install phe

import random
import sys
from phe import paillier

class BattleshipBoard:
    def __init__(self):
        self.board = [[0 for _ in range(10)] for _ in range(10)]
        self.ships = []
        self.hits = set()
        self.misses = set()

    def place_ship(self, row, col, size, direction):
        """
        direction: 'h' (horizontal) or 'v' (vertical)
        """
        if direction == 'h':
            if col + size > 10:
                return False
            for c in range(col, col + size):
                if self.board[row][c] != 0:
                    return False
                self.board[row][c] = 1
            self.ships.append([(row, c) for c in range(col, col + size)])
        else:  # vertical
            if row + size > 10:
                return False
            for r in range(row, row + size):
                if self.board[r][col] != 0:
                    return False
                self.board[r][col] = 1
            self.ships.append([(r, col) for r in range(row, row + size)])
        return True

    def auto_place_ships(self):
        """Automatically place 5 ships: 5, 4, 3, 2, 2"""
        ship_sizes = [5, 4, 3, 2, 2]
        for size in ship_sizes:
            placed = False
            while not placed:
                row = random.randint(0, 9)
                col = random.randint(0, 9)
                direction = random.choice(['h', 'v'])
                placed = self.place_ship(row, col, size, direction)

    def is_hit(self, row, col):
        """Check if coordinate has a ship"""
        return self.board[row][col] == 1

    def record_shot(self, row, col, is_hit):
        """Record hit or miss"""
        if is_hit:
            self.hits.add((row, col))
        else:
            self.misses.add((row, col))

    def all_ships_sunk(self):
        """Check if all ships are destroyed"""
        total_ship_cells = sum(len(ship) for ship in self.ships)
        return len(self.hits) == total_ship_cells

    def get_encrypted_cell(self, row, col, public_key):
        """Encrypt cell value"""
        return public_key.encrypt(self.board[row][col])


class HomomorphicBattleship:
    def __init__(self):
        print("Generating Paillier Keypair...")
        self.public_key, self.private_key = paillier.generate_paillier_keypair(n_length=2048)

        # Initialize players' boards
        self.alice_board = BattleshipBoard()
        self.bob_board = BattleshipBoard()

        print("\n[Alice] Setting up board...")
        self.alice_board.auto_place_ships()
        print("[Alice] Board ready with 5 ships (5, 4, 3, 2, 2 cells)")

        print("\n[Bob] Setting up board...")
        self.bob_board.auto_place_ships()
        print("[Bob] Board ready with 5 ships (5, 4, 3, 2, 2 cells)")

        self.turn = 0
        self.game_over = False
        self.winner = None

    def verify_shot_homomorphic(self, target_board, row, col):
        """
        Use homomorphic encryption to verify if a shot hits a ship.
        The underlying cell is 0 (water) or 1 (ship).

        Steps:
        - Encrypt the cell value (0 or 1)
        - Multiply by a random blinding factor k
        - Decrypt k * cell
            -> If cell = 0 -> result = 0 (MISS)
            -> If cell = 1 -> result = k != 0 (HIT)
        Returns: True if HIT, False if MISS.
        """

        # Encrypt the cell value using the public key
        encrypted_cell = target_board.get_encrypted_cell(row, col, self.public_key)

        # Random blinding factor (non-zero)
        blinding_factor = random.randint(1, 999_999)

        # Homomorphic scalar multiplication: Enc(m) * k = Enc(k*m)
        encrypted_result = encrypted_cell * blinding_factor

        # Only decrypt the blinded result, not the raw cell
        decrypted_val = self.private_key.decrypt(encrypted_result)

        # If decrypted_val == 0  -> original cell was 0 (MISS)
        # If decrypted_val != 0 -> original cell was 1 (HIT)
        return decrypted_val != 0

    def player_turn(self, attacker_name, target_board):
        """One player's turn to shoot, using homomorphic verification."""
        while True:
            try:
                coords = input(f"\n[{attacker_name}] Enter shot coordinates (row,col 0-9): ").strip()
                row, col = map(int, coords.split(','))

                if not (0 <= row < 10 and 0 <= col < 10):
                    print("   ! Coordinates out of bounds (0-9). Try again.")
                    continue

                if (row, col) in target_board.hits or (row, col) in target_board.misses:
                    print("   ! Already shot here. Try again.")
                    continue

                break
            except ValueError:
                print("   ! Invalid format. Use: row,col (e.g., 3,5)")
                continue

        # Use homomorphic encryption to determine hit/miss
        is_hit = self.verify_shot_homomorphic(target_board, row, col)

        # Record the outcome in plaintext tracking sets
        target_board.record_shot(row, col, is_hit)

        if is_hit:
            print(f"   *** HIT at ({row},{col})! ***")
        else:
            print(f"   --- MISS at ({row},{col}) ---")

        return is_hit

    def display_stats(self):
        """Show game statistics."""
        alice_hits = len(self.alice_board.hits)
        bob_hits = len(self.bob_board.hits)

        alice_ships_remaining = sum(len(ship) for ship in self.alice_board.ships) - alice_hits
        bob_ships_remaining = sum(len(ship) for ship in self.bob_board.ships) - bob_hits

        print(f"\n--- Game Stats ---")
        print(f"Alice: {alice_hits} hits | Ships remaining: {alice_ships_remaining} cells")
        print(f"Bob:   {bob_hits} hits | Ships remaining: {bob_ships_remaining} cells")

    def run_game(self):
        """Main game loop."""
        print("\n" + "="*50)
        print("   HOMOMORPHIC BATTLESHIP (Full Game)")
        print("="*50)

        while not self.game_over:
            self.turn += 1
            print(f"\n{'='*50}")
            print(f"TURN {self.turn}")
            print(f"{'='*50}")

            # Alice's turn
            print("\n[Alice's Turn]")
            self.player_turn("Alice", self.bob_board)
            self.display_stats()

            if self.bob_board.all_ships_sunk():
                self.winner = "Alice"
                self.game_over = True
                break

            # Bob's turn
            print("\n[Bob's Turn]")
            self.player_turn("Bob", self.alice_board)
            self.display_stats()

            if self.alice_board.all_ships_sunk():
                self.winner = "Bob"
                self.game_over = True
                break

        # Game end
        print("\n" + "="*50)
        print(f"   *** GAME OVER ***")
        print(f"   WINNER: {self.winner}!")
        print(f"   Total turns: {self.turn}")
        print("="*50)


def main():
    try:
        game = HomomorphicBattleship()
        game.run_game()
    except KeyboardInterrupt:
        print("\n\nGame exited.")
        sys.exit()


if __name__ == "__main__":
    main()

